(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{377:function(e,t,a){"use strict";a.r(t);var n=a(49),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"introduction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),a("p",[e._v("Berry ORM is an Object Relational Mapping library built for front-ends. She focuses on and "),a("strong",[e._v("only")]),e._v(" focuses on Object Relational Mapping. In other words, Berry ORM is a library used to convert between "),a("strong",[e._v("ordinary data objects")]),e._v(" and "),a("strong",[e._v("entities")]),e._v(".")]),e._v(" "),a("p",[e._v("Berry ORM attaches great importance to types, and all features have very strict type support to maximize the advantages of TypeScript.")]),e._v(" "),a("p",[e._v("You must understand that the Berry ORM is very different from the common ORM libraries in back-ends. The back-end ORM library are usually complete data management solutions, and Object Relational Mapping is only a part of their features. But Berry ORM abides by its duty and is only responsible for mapping the relations between objects, because the data source of front-ends is usually a back-end API or IndexedDB, and there are already countless mature solutions for these data sources, and you can combine the best options to manage Your data.")]),e._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[e._v("npm")]),e._v(" i berry-orm\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);